<!doctype linuxdoc system>

<!--
	BIRD documentation

    Look for "about this documentation" section to learn more.

    (set-fill-column 100)

    Copyright 1999,2000 Pavel Machek <pavel@ucw.cz>, distribute under GPL version 2 or later.

 -->

<article>

<title>BIRD
<author>
Pavel Machek <tt/pavel@ucw.cz/

<date>2000
<abstract>
This document contains documentation for BIRD Internet Routing Daemon
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<sect>Introduction

<sect1>What is BIRD

<p><label id="intro"> You may wonder what 'BIRD' means. It is acronym of 'BIRD Internet Routing
Daemon', and we think that's cool name. 

<p>Routers are devices for connecting networks. Router has several
network interfaces, listens for packets on them, and forwards packets
closer to their destination. For simple situations, such as tree,
static routing is enough and your kernel can do routing for you. For
more complicated topologies, you need routers to talk to eachother (in
order to discover alternate ways to deliver packets after network
failure). Routing deamon is the beast that accomplishes this
communication. It does not forward packets itself, but it tells kernel
where to forward them. Its task is similar to what firmware of Cisco routers does,
or what gated <HTMLURL URL="http://www.gated.org/"> or GNU zebra <HTMLURL
URL="http://www.zebra.org/"> does. However, you can not run Cisco's firmware on "normal" computer
and gated is really hard to configure and comes under wrong license. BIRD is being developed on
Charles University, Prague, and can be freely distributed under terms of GNU General Public
License. BIRD is designed to run on Unix and unix-like systems, it is primarily developed on Linux.

<sect1>About this documentation

<p>This documentation can have 4 forms: sgml (this is master copy), html, ASCII text (generated from
html) and dvi/postscript (generated from sgml using sgmltools). You should always edit master copy,
it is slightly modified linuxdoc dtd.  Anything in &lt;descrip&gt; tags is considered definition of
configuration primitives, &lt;cf&gt; is fragment of configuration within normal text, &lt;m&gt; is
"meta" information within fragment of configuration -- something in config which is not keyword.

<sect1>About routing tables

<p>Bird has one or more routing tables. Each routing table contains
list of known routes. Each route has certain attributes, most
important is prefix of network this route is for. Routing table
maintains more than one entry for network, but at most one entry for
one network and one protocol. The entry with biggest preference is
used for routing. If there are more entries with same preference and
they are from same protocol, protocol decides (typically according to
metrics). You can get list of route attributes in "Route attributes"
section in filters.

<sect>Configuration

<sect1>Introduction

<p>BIRD is configured using text configuration file. At startup, BIRD reads <file/bird.conf/ (unless
-c command line parameter is given). Configuration may be changed on user request: if you modify
config file and then signal BIRD with SIGHUP, it will adjust to new config. There's BIRD client,
which allows you to talk with BIRD in more extensive way than just telling it to reconfigure. BIRD
writes messages about its work to log files or syslog (according to config).

<p>Bird is configured using text configuration file. At startup, bird
reads <file/bird.conf/ (unless -c command line parameter is
given). Everything on a line after <cf/#/ is a comment, whitespace is
ignored, C-style comments <cf>/* comment */</cf> are also
recognized. If there's variable number of options, it is grouped using
<cf/{ }/ brackets. Each option is terminated by <cf/;/.

<p>Really simple configuration file might look like this:

<code>
protocol kernel {
	persist;		# Don't remove routes on BIRD shutdown
	scan time 20;		# Scan kernel routing table every 20 seconds
	export all;		# Default is export none
}

protocol device {
	scan time 10;		# Scan interfaces every 10 seconds
}

protocol rip {
	export all;
	import all;
}
</code>

<sect1>Global options

<p><descrip>
	<tag>log "<m/filename/"|syslog|stderr all|{ <m/list of classes/ }</tag> 
	set logging of classes (either all or <cf/{
	error, trace }/ etc.) into selected destination. Classes are:
	<cf/info/, <cf/warning/, <cf/error/, <cf/fatal/ for messages about local problems
	<cf/debug/ for debugging messages, 
	<cf/trace/ when you want to know what happens on network, 
	<cf/remote/ for messages about misbehavior of remote side, 
	<cf/auth/ about authentication failures,  
	<cf/bug/ for internal bugs
	of BIRD. You may specify more than one <cf/log/ line to log to multiple
	destinations.
				  
	<tag>debug protocols all|off|{ states, routes, filters, interfaces, events, packets }</tag>
	sets global default of protocol debugging options.

	<tag>filter <m/name/{ <m/commands/ }</tag> define filter. You can learn more about filters
	in next chapter.
 
	<tag>protocol rip|ospf|bgp|... <m/[name]/ { <m>protocol options</m> }</tag> define protocol
	instance, called name (or called something like rip5 if you omit name). You can learn more
	about configuring protocols in their own chapters. You can run more than one instance of
	most protocols (like rip or bgp).

	<tag>define constant = expression</tag> define constant. You can use it later in every place
	you could use simple integer.

	<tag>router id <m/IPv4 address/</tag> set router id. Router id needs to be world-wide
	unique. It is usually one of router's IPv4 addresses.

	<tag>table <m/name/</tag> create new routing table.

	<tag>eval <m/expr/</tag> evaluates given filter expression. It is used for testing.
</descrip>

<sect1>Protocol options

<p>Several options are per-protocol, but all protocols support them. They are described here.

<descrip>
	<tag>preference <m/expr/</tag> sets preference of routes generated by this protocol.

	<tag>disabled</tag> disables given protocol. You can disable/enable protocol from command
	line interface without needing to touch config.

	<tag>debug <m/setting/</tag> this is similar to global debug setting, except that it only
	affects one protocol. Only messages in selected debugging categories will be written to
	logs.

	<tag>import <m/filter/</tag> filter can be either either <cf> { <m>filter commands</m>
	}</cf> or <cf>filter <m/name/</cf>. Import filter works in direction from protocol to main
	routing table.

	<tag>export <m/filter/</tag> This is similar to <cf>export</cf> keyword, except that it
	works in direction from main routing table to protocol.

	<tag>table <m/name/</tag> Connect this protocol to non-default table.
</descrip>

<p>There are per-protocol options that give sense only with certain protocols.

<descrip>
	<tag>passwords { password "<m/password/" from <m/time/ to <m/time/ passive <m/time/ id
	<m/num/ [...] }</tag> specifies passwords to be used with this protocol. Passive time is
	time from which password is not announced but is allowed. id is password id, as needed by
	certain protocols.

	<tag>interface "<m/mask/"|<m/prefix/ [ { <m/option/ ; [ ... ] } ]</tag> specifies, which
	interfaces this protocol is active at, and allows you to set options on
	interface-by-interface basis. Mask is specified in shell-like patters, thus <cf>interface
	"*" { mode broadcast; };</cf> will start given protocol on all interfaces, with <cf>mode
	broadcast;</cf> option.
						  
</descrip>

<sect>Filters

<sect1>Introduction

<p>BIRD contains rather simple programming language. (No, it can not yet read mail :-). There are
two objects in this language: filters and functions. Filters are called by BIRD core when route is
being passed between protocol and main routing table, and filters may call functions. Functions may
call other functions, but recursion is not allowed. Filter language contains control structures such
as if's and switches, but it allows no loops. Filters are
interpreted. Filter using many features can be found in <file>filter/test.conf</file>. 

<p>You can find sources of filters language in <file>filter/</file>
directory. <file>filter/config.Y</file> contains filter grammar, and basically translates source from
user into tree of <cf>f_inst</cf> structures. These trees are later interpreted using code in
<file>filter/filter.c</file>. Filters internally work with values/variables in <tt>struct
f_val</tt>, which contains type of value and value.

<p>Filter basically gets the route, looks at its attributes and
modifies some of them if it wishes. At the end, it decides, whether to
pass change route through (using <cf/accept/), or whether to <cf/reject/ given route. It looks
like this:

<code>
filter not_too_far
int var;
{
	if defined( rip_metric ) then
		var = rip_metric;
	else {
		var = 1;
		rip_metric = 1;
	}
	if rip_metric &gt; 10 then
		reject "RIP metric is too big";
	else
		accept "ok";
}
</code>

<p>As you can see, filter has a header, list of local variables, and body. Header consists of
<cf/filter/ keyword, followed by (unique) name of filter. List of local variables consists of
pairs <cf><M>type name</M>;</cf>, where each pair defines one local variable. Body consists of
<cf> { <M>statements</M> }</cf>. Statements are terminated by <cf/;/. You can group
several statements into one by <cf>{ <M>statements</M> }</cf> construction, that is useful if
you want to make bigger block of code conditional.

<p>There are two special filters, <cf/all/ (which accepts all routes) and <cf/none/ (which rejects
all routes).


<p>Bird supports functions, so that you don't have to repeat same blocks of code over and
over. Functions can have zero or more parameters, and can have local variables. Function basically
looks like this:

<code>
function name ()
int local_variable;
{
	local_variable = 5;
}

function with_parameters (int parameter)
{
	print parameter;
}
</code>

<p>Unlike C, variables are declared after function line but before first {. You can not declare
variables in nested blocks. Functions are called like in C: <cf>name();
with_parameters(5);</cf>. Function may return value using <cf>return <m/[expr]/</cf>
syntax. Returning value exits from current function (this is similar to C).

<p>Filters are declared in similar way to functions, except they can not have explicit
parameters. They get route table entry as implicit parameter. Route table entry is passed implicitly
to any functions being called. Filter must terminate with either
accept or reject statement. If there's runtime error in filter, route
is rejected. 

<sect1>Data types

<p>Each variable and each value has certain type. Unlike C, filters distinguish between integers and
booleans (that is to prevent you from shooting in the foot).

<descrip>
	<tag/bool/ this is boolean type, it can have only two values, <cf/TRUE/ and
	  <cf/FALSE/. Boolean is not compatible with integer and is the only type you can use in if
	  statements.

	<tag/int/ this is common integer, you can expect it to store signed values from -2000000000
	  to +2000000000.

	<tag/pair/ this is pair of two short integers. Each component can have values from 0 to
	  65535. Constant of this type is written as <cf/(1234,5678)/.

	<tag/string/ this is string of characters. There are no ways to modify strings in
	  filters. You can pass them between functions, assign to variable of type string, print
	  such variables, but you can not concatenate two strings (for example). String constants
	  are written as <cf/"This is a string constant"/.

	<tag/ip/ this type can hold single ip address. Depending on version of BIRD you are using, it
	  can be IPv4 or IPv6 address. IPv4 addresses are written (as you would expect) as
	  <cf/1.2.3.4/. You can apply special operator <cf>.mask(<M>num</M>)</cf>
	  on values of type ip. It masks out all but first <cf><M>num</M></cf> bits from ip
	  address. So <cf/1.2.3.4.mask(8) = 1.0.0.0/ is true.

	<tag/prefix/ this type can hold ip address, prefix len pair. Prefixes are written as
	  <cf><M>ipaddress</M>/<M>pxlen</M></cf>, or
	  <cf><m>ipaddress</m>/<m>netmask</m></cf> There are two special
	  operators on prefix:
	  <cf/.ip/, which separates ip address from the pair, and <cf/.len/, which separates prefix
	  len from the pair.

	<tag/int|ip|prefix|pair set/
	  filters know four types of sets. Sets are similar to strings: you can pass them around
	  but you can not modify them. Constant of type <cf>set int</cf> looks like <cf>
	  [ 1, 2, 5..7 ]</cf>. As you can see, both simple values and ranges are permitted in
	  sets. Sets of prefixes are special: you can specify which prefixes should match them by
	  using <cf>[ 1.0.0.0/8+, 2.0.0.0/8-, 3.0.0.0/8{5,6} ]</cf>. 3.0.0.0/8{5,6} matches
	  prefixes 3.X.X.X, whose prefix length is 5 to 6. 3.0.0.0/8+ is shorthand for 3.0.0.0/{0,8},
	  3.0.0.0/8- is shorthand for 3.0.0.0/{0,7}.

	<tag/enum/
	  enumeration types are halfway-internal in the BIRD. You can not define your own
	  variable of enumeration type, but some predefined variables are of enumeration
	  type. Enumeration types are incompatible with each other, again, for your
	  protection.

	<tag/bgppath/
	  bgp path is list of autonomous systems.

	<tag/bgpmask/ 
	  bgp mask is mask used for matching bgp paths
	  (using <cf>path ~ / 2 3 5 ? / syntax </cf>). <cf/?/ is
	  really serving in "any number of autonomous systems", but we
	  did not want to use * because then it becomes too easy to
	  write <cf>/*</cf> which is start of comment.

	<tag/clist/ 
	  community list. This is similar to set of pairs,
	  except that unlike other sets, it can be modified.

	  
</descrip>

<sect1>Operations

<p>Filter language supports common integer operations <cf>(+,-,*,/)</cf>, parentheses <cf/(a*(b+c))/, comparison
<cf/(a=b, a!=b, a&lt;b, a&gt;=b)/. Special operators include <cf/&tilde;/ for "in" operation. In operation can be
used on element and set of that elements, or on ip and prefix, or on
prefix and prefix or on bgppath and bgpmask or on pair and clist. Its result
is true if element is in given set or if ip address is inside given prefix. Operator <cf/=/ is used to assign value
to variable.

<sect1>Control structures

<p>Filters support two control structures: if/then/else and case. Syntax of if/then/else is <cf>if
<M>expression</M> then <M>command</M>; else <M>command</M>;</cf> and you can use <cf>{
<M>command_1</M>; <M>command_2</M>; <M>...</M> }</cf> instead of one or both commands. <cf>else</cf>
clause may be omitted.

<p><cf>case</cf> is similar to case from Pascal. Syntax is <cf>case <m/expr/ { else |
<m/num_or_prefix [ .. num_or_prefix]/ : <m/statement/ ; [ ... ] }</cf>. Expression after
<cf>case</cf> can be of any type that can be on the left side of &tilde; operator, and anything that could
be member of set is allowed before :. Multiple commands are allowed without {} grouping. If argument
matches neither of : clauses, else: clause is used. (Case is actually implemented as set matching,
internally.)

<p>Here is example that uses if and case structures:

<code>
case arg1 {
	2: print "two"; print "I can do more commands without {}";
	3 .. 5: print "three to five";
	else: print "something else";
	}

if 1234 = i then printn "."; else { print "*** FAIL: if 1 else"; }
</code>

<sect1>Route attributes

<p>Filter is implicitly passed route, and it can access its attributes, just like it accesses variables.

<descrip>
	<tag>defined( <m>attribute</m> )</tag>
	returns TRUE if given attribute is defined. Access to undefined attribute results in runtime error.

	<tag/<m/prefix/ network/
	network this route is talking about.

	<tag/<m/ip/ from/
	who told me about this route.
	
	<tag/<m/ip/ gw/
	what is next hop packets routed using this route should be forwarded to.

	<tag/<m/enum/ source/
	what protocol told me about this route. This can have values such as <cf/RTS_RIP/ or <cf/RTS_OSPF_EXT/.
</descrip>

<p>Plus, there are protocol-specific attributes, which are described in protocol sections.

<sect1>Utility functions

<p>There are few functions you might find convenient to use:

<descrip>
	<tag>print <m/expr/ [ <m/, expr .../ ]</tag>
	prints given expressions, useful mainly while debugging filters.

	<tag>quitbird</tag>
	terminates bird. Useful while debugging filter interpreter.
</descrip>

<sect>Protocols

<sect1>BGP

<sect1>Device

<sect1>Direct

<sect1>Kernel

<sect1>OSPF

<sect1>Pipe

<sect1>Rip

<sect2>Introduction

<p>Rip protocol (sometimes called Rest In Pieces) is simple protocol, where each router broadcasts
distances to all networks he can reach. When router hears distance to other network, it increments
it and broadcasts it back. Broadcasts are done in regular intervals. Therefore, if some network goes
unreachable, routers keep telling each other that distance is old distance plus 1 (actually, plus
interface metric, which is usually one). After some time, distance reaches infinity (that's 15 in
rip) and all routers know that network is unreachable. Rip tries to minimize situations where
counting to infinity is necessary, because it is slow. Due to infinity being 16, you can not use
rip on networks where maximal distance is bigger than 15 hosts. You can read more about rip at <HTMLURL
URL="http://www.ietf.org/html.charters/rip-charter.html">.

<sect2>Configuration

<p>In addition to options generic to other protocols, rip supports following options:

<descrip>
	<tag/authentication none|password|md5/ selects authentication method to use. None means that
	  packets are not authenticated at all, password means that plaintext password is embedded
	  into each packet, and md5 means that packets are authenticated using md5 cryptographic
	  hash. If you set authentication to non-none, it is good idea to add <cf>passwords { }</cf>
	  section.

	<tag>honor always|neighbor|never </tag>specifies, when should be routing table updates
	  honored. (Always, when sent from host on directly connected network, or never.)
</descrip>

<p>There are two options that can be specified per-interface. First is <cf>metric</cf>, with
default one.  Second is <cf>mode multicast|broadcast|quiet|nolisten|version1</cf>, it selects mode for
rip to work in. If nothing is specified, rip runs in multicast mode. <cf>version1</cf> is
currently equivalent to <cf>broadcast</cf>, and it makes rip talk at broadcast address even
through multicast mode is possible. <cf>quiet</cf> option means that rip will not transmit
periodic messages onto this interface and <cf>nolisten</cf> means that rip will talk to this
interface but not listen on it.

<p>Following options generally override specified behavior from rfc. If you use any of these
options, BIRD will no longer be rfc-compatible, which means it will not be able to talk to anything
other than equally misconfigured BIRD. I warned you.

<descrip>
	<tag>port <M>number</M></tag>
	  selects IP port to operate on, default 520. (This is useful when testing BIRD, if you
	  set this to address &gt;1024, you will not need to run bird with UID==0).

	<tag>infinity <M>number</M></tag>
	  select value of infinity, default 16. Bigger values will make protocol convergence
	  even slower.

	<tag>period <M>number</M>
	  </tag>specifies number of seconds between periodic updates. Default is 30 seconds. Lower
	  number will mean faster convergence but bigger network load.

	<tag>timeouttime <M>number</M>
	  </tag>specifies how old route has to be to be considered unreachable. Default is 4*period.

	<tag>garbagetime <M>number</M>
	  </tag>specifies how old route has to be to be discarded. Default is 10*period.
</descrip>

<sect2>Attributes

<p>RIP defines two route attributes:

<descrip>
	<tag>int <cf/rip_metric/</tag> RIP metric of the route (ranging from 0 to <cf/infinity/).
	When routes from different RIP instances are available and all of them have the same
	preference, BIRD prefers the route with lowest <cf/rip_metric/.

	<tag>int <cf/rip_tag/</tag> RIP route tag: a 16-bit number which can be used
	to carry additional information with the route (for example, an originating AS number
	in case of external routes).
</descrip>

<sect2>Example

<p><code>
protocol rip MyRIP_test {
        debug all;
        port 1520;
        period 7;
        garbagetime 60;
        interface "eth0" { metric 3; mode multicast; } "eth1" { metric 2; mode broadcast; };
        honor neighbour;
        passwords { password "ahoj" from 0 to 10;
                password "nazdar" from 10;
        }
        authentication none;
        import filter { print "importing"; accept; };
        export filter { print "exporting"; accept; };
}
</code>

<sect1>Static

<sect>Getting more help

<p>This is really last section of this file, should give pointers to
programmers documentation, web pages mailing lists and similar stuff.


</article>


<!--
# LocalWords: IPv doctype verb GPL Cisco sgml html Cisco's unix dvi sgmltools linuxdoc dtd descrip config conf syslog stderr auth ospf bgp router's IP expr num inst bool int ip px len enum cf md eval ipaddress pxlen netmask bgppath bgpmask clist gw RTS EXT quitbird nolisten UID timeouttime garbagetime rfc doc 
-->