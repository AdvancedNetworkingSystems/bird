/*
 *	BIRD -- Multi-Threaded Routing Toolkit (MRT) Routing Information Export Format Tests
 *
 *	(c) 2015 CZ.NIC z.s.p.o.
 *
 *	Can be freely distributed and used under the terms of the GNU GPL.
 */

#include "test/birdtest.h"
#include "test/birdtest_support.h" /* REMOVE ME */
#include "nest/mrtdump.h"
#include "nest/rt-fib.c" /* REMOVE ME */
#include "nest/mrtdump.c" /* REMOVE ME */

static void
show_mrt_msg(struct mrt_buffer *msg)
{
  uint i;
  bt_debug("show_mrt_msg: \n  ");
  for (i = 0; i < msg->msg_length; i++)
  {
    if (i && (i % 16) == 0)
      bt_debug("\n  ");
    bt_debug("%02X ", msg->msg[i]);
  }
  bt_debug("\n");
}

static void
compare(const byte *expected, const byte *data, u32 length)
{
  u32 i;
  for(i = 0; i < length; i++)
    bt_assert_msg(expected[i] == data[i], "Different at %d, 0x%02X != 0x%02X", i, expected[i], data[i]);
}

static int
t_peer_index_table(void)
{
  resource_init();

  struct mrt_peer_index_table state;

  u32 collector_bgp_id = 0x12345678;
  const char *collector_name = "test";
  mrt_peer_index_table_header(&state, collector_bgp_id, collector_name);

  u32 i;
  for (i = 0; i < 5; i++)
  {
    ip_addr addr;
#ifdef IPV6
    ip6_pton("1234:5678::9abc:def0", &addr);
#else
    ip4_pton("12.34.56.78", &addr);
#endif
    mrt_peer_index_table_add_peer(&state, i | 0x30303030, i | 0x08080808, addr);
  }

  show_mrt_msg(&state.msg);

  const byte expected[] = {
      /* Reserve for the main MRT Header */
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 12 bytes */
      /* PEER_INDEX_TABLE Header */
      0x12, 0x34, 0x56, 0x78,   0x00, 0x04,   0x74, 0x65, 0x73, 0x74,   0x00, 0x05,	/* 12 bytes */
      /* Peer Entries */
#ifdef IPV6
      0x03,   0x30, 0x30, 0x30, 0x30,   0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9A, 0xBC, 0xDE, 0xF0,   0x08, 0x08, 0x08, 0x08,
      0x03,   0x30, 0x30, 0x30, 0x31,   0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9A, 0xBC, 0xDE, 0xF0,   0x08, 0x08, 0x08, 0x09,
      0x03,   0x30, 0x30, 0x30, 0x32,   0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9A, 0xBC, 0xDE, 0xF0,   0x08, 0x08, 0x08, 0x0A,
      0x03,   0x30, 0x30, 0x30, 0x33,   0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9A, 0xBC, 0xDE, 0xF0,   0x08, 0x08, 0x08, 0x0B,
      0x03,   0x30, 0x30, 0x30, 0x34,   0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9A, 0xBC, 0xDE, 0xF0,   0x08, 0x08, 0x08, 0x0C,
#else
      0x02,   0x30, 0x30, 0x30, 0x30,   0x0C, 0x22, 0x38, 0x4E,   0x08, 0x08, 0x08, 0x08,
      0x02,   0x30, 0x30, 0x30, 0x31,   0x0C, 0x22, 0x38, 0x4E,   0x08, 0x08, 0x08, 0x09,
      0x02,   0x30, 0x30, 0x30, 0x32,   0x0C, 0x22, 0x38, 0x4E,   0x08, 0x08, 0x08, 0x0A,
      0x02,   0x30, 0x30, 0x30, 0x33,   0x0C, 0x22, 0x38, 0x4E,   0x08, 0x08, 0x08, 0x0B,
      0x02,   0x30, 0x30, 0x30, 0x34,   0x0C, 0x22, 0x38, 0x4E,   0x08, 0x08, 0x08, 0x0C,
#endif
  };

  bt_assert(state.msg.msg_length == sizeof(expected));
  compare(expected, state.msg.msg, sizeof(expected));

  mrt_buffer_free(&state.msg);
  return BT_SUCCESS;
}

static int
t_rib_table(void)
{
  resource_init();

  struct mrt_rib_table state;
  u32 sequence_number = 0x12345678;
  u8 prefix_len = 24;
  ip_addr prefix;
#ifdef IPV6
  ip6_pton("1234:5678::9abc:def0", &prefix);
#else
  ip4_pton("12.34.56.78", &prefix);
#endif
  mrt_rib_table_alloc(&state);
  mrt_rib_table_header(&state, sequence_number, prefix_len, prefix, MRT_RIB_NO_ADDPATH);

  u32 i;
  for(i = 0; i < 5; i++)
  {
    struct mrt_rib_entry entry = {
	.peer_index =      i,
	.originated_time = i | 0x08080808,
	.attributes_length = 7,
	.attributes = "abcdefg",
    };
    mrt_rib_table_add_entry(&state, &entry);
  }

  show_mrt_msg(&state.msg);

  const byte expected[] = {
      /* Reserve for the main MRT Header */
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      /* AFI/SAFI-Specific RIB Table Header */
#ifdef IPV6
      0x12, 0x34, 0x56, 0x78,   0x18,   0x12, 0x34, 0x56,    0x00, 0x05,
#else
      0x12, 0x34, 0x56, 0x78,   0x18,   0x0C, 0x22, 0x38,    0x00, 0x05,
#endif
      /* RIB Entries */
      0x00, 0x00,   0x08, 0x08, 0x08, 0x08,   0x00, 0x07,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x00, 0x01,   0x08, 0x08, 0x08, 0x09,   0x00, 0x07,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x00, 0x02,   0x08, 0x08, 0x08, 0x0A,   0x00, 0x07,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x00, 0x03,   0x08, 0x08, 0x08, 0x0B,   0x00, 0x07,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
      0x00, 0x04,   0x08, 0x08, 0x08, 0x0C,   0x00, 0x07,   0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
  };

  bt_assert(state.msg.msg_length == sizeof(expected));
  compare(expected, state.msg.msg, sizeof(expected));

  mrt_buffer_free(&state.msg);
  return BT_SUCCESS;
}

int
main(int argc, char *argv[])
{
  bt_init(argc, argv);

  bt_test_suite(t_peer_index_table, 	"MRT Table Dump: Peer index table");
  bt_test_suite(t_rib_table, 		"MRT Table Dump: RIB table");

  return bt_end();
}
